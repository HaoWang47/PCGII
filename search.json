[{"path":"https://haowang47.github.io/PCGII/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 PCGII authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"intro","dir":"Articles","previous_headings":"","what":"Intro","title":"Introduction","text":"PCGII R package developed Information-incorporated Gene Network Construction FDR Control. PCGII stands Partial Correlation Graphs Information Incorporation. start using PCGII, prepare gene expression data prior knowledge gene-gene direct associations target network. Two methods implemented package, PCGII case prior knowledge CLEVEL case prior knowledge. can select one two methods construct gene network. Incorporating false information lead inflation empirical FDR. result, strongly recommend incorporating high-confidence information real data applications.","code":"# devtools::install_github(\"HaoWang47/PCGII\") library(PCGII) #> Loading required package: corpcor #> Loading required package: igraph #>  #> Attaching package: 'igraph' #> The following objects are masked from 'package:stats': #>  #>     decompose, spectrum #> The following object is masked from 'package:base': #>  #>     union #> Loading required package: tidyverse #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.5 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.4.4     ✔ tibble    3.2.1 #> ✔ lubridate 1.9.3     ✔ tidyr     1.3.1 #> ✔ purrr     1.0.2      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ lubridate::%--%()      masks igraph::%--%() #> ✖ dplyr::as_data_frame() masks tibble::as_data_frame(), igraph::as_data_frame() #> ✖ purrr::compose()       masks igraph::compose() #> ✖ tidyr::crossing()      masks igraph::crossing() #> ✖ dplyr::filter()        masks stats::filter() #> ✖ dplyr::lag()           masks stats::lag() #> ✖ purrr::simplify()      masks igraph::simplify() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors #> Loading required package: Matrix #>  #>  #> Attaching package: 'Matrix' #>  #>  #> The following objects are masked from 'package:tidyr': #>  #>     expand, pack, unpack #>  #>  #> Loading required package: mvtnorm #>  #> Loading required package: glmnet #>  #> Loaded glmnet 4.1-8 set.seed(010120000)"},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"simulate-network-and-prepare-data","dir":"Articles","previous_headings":"","what":"Simulate Network and Prepare Data","title":"Introduction","text":"Three methods generating network structure included PCGII, including Scale Free Network Structure, Random Connection Network Structure, Block Diagonal Network Structure. section, illustrate expected data preparation. start network 100 nodes. True Network Connections, auto-layout True Network Connections, circle-layout illustration, randomly selection partial true connections use prior knowledge. carefully considered prior connections undirected (.e. -B ->B & B->) practice. PCGII framework, recommended use undirected connections prior information. Prior Network Connections, circle-layout","code":"## Simulate precision matrix as your true network structure N_nodes = 100 N_samples = 30 Omega = make_sf_precision_mat(e = 1, p = N_nodes) ## Display the true network nodenames = 1:N_nodes links = which(lower.tri(Omega) & Omega!=0, arr.ind = TRUE) dim(links) # display number of connections, two columns correspond to the connected nodes #> [1] 99  2 my_net <- graph_from_data_frame(d=links, vertices=nodenames, directed=F)  Ecolrs=c(\"gray50\") Vcolrs=c(\"gold\") plot(my_net,       edge.arrow.size=.5,       edge.color=Ecolrs,      vertex.frame.color=\"#ffffff\",      vertex.label.color=\"black\",      vertex.size=3,      layout=layout.auto(my_net)) plot(my_net,       edge.arrow.size=.5,       edge.color=Ecolrs,      vertex.frame.color=\"#ffffff\",      vertex.label.color=\"black\",      vertex.size=3,      layout=layout.circle(my_net)) ## Simulate Normal data Sigma = solve(Omega) mu = exp(qnorm(seq(from = 0.01, to = 0.99, length.out = N_nodes), mean = 2, sd=1)) norm_data = mvtnorm::rmvnorm(n = N_samples, mean = mu, sigma = Sigma) ## Convert simulated normal data to expression count data norm_data[norm_data<0] = 0 Exp_data = round(norm_data) head(Exp_data[,1:10]) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    0    0    0    3    1    3    1    2    3     2 #> [2,]    1    1    1    2    1    1    2    2    1     2 #> [3,]    0    1    1    1    3    1    0    3    1     4 #> [4,]    0    0    1    2    1    1    3    3    3     2 #> [5,]    3    0    2    4    0    2    1    4    0     0 #> [6,]    1    1    1    0    2    2    2    0    5     2 prior_links = links[sample(1:nrow(links), .2*nrow(links)),] types = rep(1, 99) types[prior_links] = 2 # 1 for unknown true connections, 2 for known prior connections undirected_prior_links = undirected_prior(prior_links) prior_net = graph_from_data_frame(d=cbind(links,types), vertices=nodenames, directed=F)  #> Warning in cbind(links, types): number of rows of result is not a multiple of #> vector length (arg 2) Ecolrs=c(\"grey90\", \"grey10\") # dark grey shows known prior connections E(prior_net)$color = Ecolrs[E(prior_net)$types] Vcolrs=c(\"gold\") plot(prior_net,       edge.arrow.size=.5,       vertex.frame.color=\"#ffffff\",      vertex.label.color=\"black\",      vertex.size=3,      layout=layout.circle(my_net))"},{"path":[]},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"pcgii-inference","dir":"Articles","previous_headings":"Analyses with PCGII and CLEVEL","what":"PCGII Inference","title":"Introduction","text":"","code":"fixed_lamdba = sqrt(2*log(N_nodes/sqrt(N_samples))/N_samples) PCGII.out = PCGII(df = Exp_data, prior = undirected_prior_links, lambda = fixed_lamdba) PCGII.inf = inference(PCGII.out, alpha = .1)"},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"display-significant-connections-detected-by-pcgii","dir":"Articles","previous_headings":"Analyses with PCGII and CLEVEL","what":"Display significant connections detected by PCGII","title":"Introduction","text":"Network Recovered PCGII, circle-layout","code":"PCGII_links = which(lower.tri(PCGII.inf) & PCGII.inf!=0, arr.ind = TRUE) dim(PCGII_links) # display number of connections detected by PCGII #> [1] 45  2 PCGII_net <- graph_from_data_frame(d=PCGII_links, vertices=nodenames, directed=F)  Ecolrs=c(\"blue\") Vcolrs=c(\"gold\") plot(PCGII_net,       edge.arrow.size=.5,       edge.color=Ecolrs,      vertex.frame.color=\"#ffffff\",      vertex.label.color=\"black\",      vertex.size=3,      layout=layout.circle(PCGII_net))"},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"pcgii-inference-1","dir":"Articles","previous_headings":"Analyses with PCGII and CLEVEL","what":"PCGII Inference","title":"Introduction","text":"","code":"CLEVEL.out = clevel(df = Exp_data, lambda = fixed_lamdba) CLEVEL.inf = inference(CLEVEL.out, alpha = .1)"},{"path":"https://haowang47.github.io/PCGII/articles/Introduction.html","id":"display-significant-connections-detected-by-pcgii-1","dir":"Articles","previous_headings":"Analyses with PCGII and CLEVEL","what":"Display significant connections detected by PCGII","title":"Introduction","text":"Network Recovered CLEVEL, circle-layout","code":"CLEVEL_links = which(lower.tri(CLEVEL.inf) & CLEVEL.inf!=0, arr.ind = TRUE) dim(CLEVEL_links) # display number of connections detected by PCGII #> [1] 38  2 CLEVEL_net <- graph_from_data_frame(d=CLEVEL_links, vertices=nodenames, directed=F)  Ecolrs=c(\"blue\") Vcolrs=c(\"gold\") plot(CLEVEL_net,       edge.arrow.size=.5,       edge.color=Ecolrs,      vertex.frame.color=\"#ffffff\",      vertex.label.color=\"black\",      vertex.size=3,      layout=layout.circle(CLEVEL_net))"},{"path":"https://haowang47.github.io/PCGII/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hao Wang. Maintainer.","code":""},{"path":"https://haowang47.github.io/PCGII/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wang H, Qiu Y, Liu P (2024). PCGII: Partial Correlation Graph Information Incorporation. R package version 1.1.2, https://haowang47.github.io/PCGII/.","code":"@Manual{,   title = {PCGII: Partial Correlation Graph with Information Incorporation},   author = {Hao Wang and Yumou Qiu and Peng Liu},   year = {2024},   note = {R package version 1.1.2},   url = {https://haowang47.github.io/PCGII/}, }"},{"path":"https://haowang47.github.io/PCGII/index.html","id":"pcgii--license-mit-v3","dir":"","previous_headings":"","what":"Partial Correlation Graph with Information Incorporation","title":"Partial Correlation Graph with Information Incorporation","text":"R Package Information-incorporated Gene Network Construction FDR Control","code":""},{"path":"https://haowang47.github.io/PCGII/index.html","id":"authors","dir":"","previous_headings":"","what":"Authors:","title":"Partial Correlation Graph with Information Incorporation","text":"Hao Wang, Yumou Qiu Peng Liu.","code":""},{"path":"https://haowang47.github.io/PCGII/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact:","title":"Partial Correlation Graph with Information Incorporation","text":"[haydo.wang@outlook.com] (Hao Wang)","code":""},{"path":"https://haowang47.github.io/PCGII/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation:","title":"Partial Correlation Graph with Information Incorporation","text":"Wang, H., Qiu, Y.*, Guo, H., Yin, Y., Liu, P.*, 2024. Information-incorporated Gene Network Construction FDR Control. review.","code":""},{"path":"https://haowang47.github.io/PCGII/index.html","id":"installation-and-package-loading","dir":"","previous_headings":"","what":"Installation and Package loading","title":"Partial Correlation Graph with Information Incorporation","text":"tutorial script researchers interested applying PCGII omics data learn direct association structure omics features. main function PGCII() takes biologically pre-processed expression data matrix input, returns list statistics (estimates test statistics). function inference() takes list returned PGCII() input conduct simultaneous test identify significant partial correlations False Discovery Rate (FDR) controlled pre-determined nominal level (0.05 default).","code":"# R version is required >= 3.4.4 # When the first time to use the package, please make sure dependent packages are installed under your R environment, if not, please use commands below to install > #install.packages(\"tidyverse\") > #install.packages(\"glmnet\") > #install.packages(\"mvtnorm\") > #install.packages(\"igraph\") > #install.packages(\"Matrix\") # install \"devtools\" package in your R environment > # devtools::install_github(\"HaoWang47/PCGII\") > library(PCGII)"},{"path":"https://haowang47.github.io/PCGII/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Partial Correlation Graph with Information Incorporation","text":"PCGII() df: main expression data, n p matrix/dataframe, row corresponds sample column represents expression/abundance omics feature; prior: prior set, k 2 dataframe, row corresponds pair nodes (omics features) connected prior belief. Note, prior input dataframe column names “row” “col”; lambda: regularization parameter, used node-wise regression. missing, default lambda used order $\\sqrt{2\\times log(p/\\sqrt{n})/n}$. Remark: mathematical standardization automatically done within function. Est: estimated partial correlation matrix; EstThresh: sparse partial correlation estimation matrix threshold; kappa: estimated ratio forth squared second moment residuals, please refer manuscript details; tscore: estimated test statistics matrix partial correlations; n: sample size; p: number genes study. Inference() list: list returned either PCGII() clevel(). alpha: pre-determined False Discovery Rate. Nominal FDR set 0.05 default. Output: adjacency matrix significant partial correlations.","code":""},{"path":"https://haowang47.github.io/PCGII/index.html","id":"network-analysis","dir":"","previous_headings":"","what":"Network Analysis","title":"Partial Correlation Graph with Information Incorporation","text":"Simulate data X scale-free network g. Network analysis data matrix X.","code":"> # Simulating data > set.seed(1234567) > n=50 # sample size > p=30 # number of nodes > > omega=make_random_precision_mat(eta=.01, p=p) > > Sigma=solve(omega) # population covariance matrix, which is used to generate data > X = rmvnorm(n = n, sigma = Sigma) # simulate expression data > # determine tuning parameter: fixed lambda > lam=2*sqrt(log(p)/n) > > # create prior set: directed prior network > prior_set=matrix(data=c(6,5, 28,14), nrow=2, ncol=2, byrow = TRUE) > colnames(prior_set)=c(\"row\", \"col\") > PCGII_out=PCGII(df=X, prior=as.data.frame(prior_set), lambda = lam) > inference_out=inference(list=PCGII_out) > diag(inference_out)=0 > # Visualization > inference_out %>% +   graph_from_adjacency_matrix(mode = \"undirected\") %>% +   plot(vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5) > > # create prior set: undirected prior network > PCGII_out=PCGII(df=X, prior=undirected_prior(prior_set), lambda = lam) > inference_out=inference(list=PCGII_out) > diag(inference_out)=0 > # Visualization > inference_out %>% +   graph_from_adjacency_matrix(mode = \"undirected\") %>% +   plot(vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5)"},{"path":"https://haowang47.github.io/PCGII/reference/PCGII.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the estimated partial correlation graph with information incorporation — PCGII","title":"Get the estimated partial correlation graph with information incorporation — PCGII","text":"PCGII() function apply proposed method get estimated partial correlation graph information incorporation","code":""},{"path":"https://haowang47.github.io/PCGII/reference/PCGII.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the estimated partial correlation graph with information incorporation — PCGII","text":"","code":"PCGII(df, prior, lambda)"},{"path":"https://haowang47.github.io/PCGII/reference/PCGII.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the estimated partial correlation graph with information incorporation — PCGII","text":"df main expression dataset, n p matrix, row corresponds sample column represents expression/abundance omics feature. prior prior set, k 2 dataframe, row corresponds pair nodes (omics features) connected prior belief. Note, prior input dataframe. lambda regularization parameter, used node-wise regression. missing, default lambda used order sqrt(2*log(p)/n).","code":""},{"path":"https://haowang47.github.io/PCGII/reference/PCGII.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the estimated partial correlation graph with information incorporation — PCGII","text":"list. list contains estimated partial correlation matrix (Est), sparse partial correlation estimation matrix threshold (EstThresh), estimated kappa (kappa), estimated test statistics matrix partial correlations (tscore), sample size (n) number nodes (p).","code":""},{"path":"https://haowang47.github.io/PCGII/reference/PCGII.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the estimated partial correlation graph with information incorporation — PCGII","text":"","code":"library(igraph) library(tidyverse) library(PCGII) library(mvtnorm) # Simulating data set.seed(1234567) n=50 # sample size p=30 # number of nodes  omega=make_random_precision_mat(eta=.01, p=p)  # population covariance matrix, which is used to generate data Sigma=solve(omega) # simulate expression data X = rmvnorm(n = n, sigma = Sigma)  lam=2*sqrt(log(p)/n) ## fixed lambda  # directed prior network prior_set=as.data.frame(matrix(data=c(5,6, 28,24), nrow=2, ncol=2, byrow = TRUE)) colnames(prior_set)=c(\"row\", \"col\") prior_set=undirected_prior(prior_set) PCGII_out=PCGII(df=X, prior=prior_set, lambda = lam) inference_out=inference(list=PCGII_out) diag(inference_out)=0 net=inference_out %>% graph_from_adjacency_matrix(mode = \"undirected\") net %>% plot(vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5, layout=layout_in_circle(net))  ## Remark: mathematical standardization will be automatically done within the function."},{"path":"https://haowang47.github.io/PCGII/reference/clevel.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the estimated partial correlation graph without information incorporation — clevel","title":"Get the estimated partial correlation graph without information incorporation — clevel","text":"clevel() function apply method originally proposed paper '> Qiu, Y., & Zhou, X. H. (2020). Estimating c-level partial correlation graphs application brain imaging. used get estimated partial correlation graph without information incorporation.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/clevel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the estimated partial correlation graph without information incorporation — clevel","text":"","code":"clevel(df, lambda)"},{"path":"https://haowang47.github.io/PCGII/reference/clevel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the estimated partial correlation graph without information incorporation — clevel","text":"df main expression dataset, n p matrix, row corresponds sample column represents expression/abundance omics feature. lambda regularization parameter, used node-wise regression. missing, default lambda used order sqrt(2*log(p)/n).","code":""},{"path":"https://haowang47.github.io/PCGII/reference/clevel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the estimated partial correlation graph without information incorporation — clevel","text":"list. list contains estimated partial correlation matrix (Est), sparse partial correlation estimation matrix threshold (EstThresh), estimated kappa (kappa), estimated test statistics matrix partial correlations (tscore), sample size (n) number nodes (p).","code":""},{"path":"https://haowang47.github.io/PCGII/reference/clevel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the estimated partial correlation graph without information incorporation — clevel","text":"","code":"library(igraph) library(tidyverse) library(PCGII) library(mvtnorm) # Simulating data set.seed(1234567) n=50 # sample size p=30 # number of nodes  omega=make_random_precision_mat(eta=.01, p=p)  # population covariance matrix, which is used to generate data Sigma=solve(omega) # simulate expression data X = rmvnorm(n = n, sigma = Sigma)  lam=2*sqrt(log(p)/n) ## fixed lambda  CLEVEL_out=clevel(df=X, lambda = lam) inference_out=inference(list=CLEVEL_out) diag(inference_out)=0 net=inference_out %>% graph_from_adjacency_matrix(mode = \"undirected\") net %>% plot(vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5, layout=layout_in_circle(net))  ## Remark: mathematical standardization will be automatically done within the function."},{"path":"https://haowang47.github.io/PCGII/reference/inference.html","id":null,"dir":"Reference","previous_headings":"","what":"Conduct simultaneous inference of estimated partial correlations — inference","title":"Conduct simultaneous inference of estimated partial correlations — inference","text":"Inference() function conduct simultaneous inference estimated partial correlations.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/inference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conduct simultaneous inference of estimated partial correlations — inference","text":"","code":"inference(list, alpha = 0.05)"},{"path":"https://haowang47.github.io/PCGII/reference/inference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conduct simultaneous inference of estimated partial correlations — inference","text":"list list returned either `PCGII()` `clevel()`. alpha pre-determined False Discovery Rate. Nominal FDR set 0.05 default.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/inference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conduct simultaneous inference of estimated partial correlations — inference","text":"adjacency matrix significant partial correlations.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/inference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conduct simultaneous inference of estimated partial correlations — inference","text":"","code":"library(igraph) library(tidyverse) library(PCGII) library(mvtnorm) # Simulating data set.seed(1234567) n=50 # sample size p=30 # number of nodes  omega=make_random_precision_mat(eta=.01, p=p)  # population covariance matrix, which is used to generate data Sigma=solve(omega) # simulate expression data X = rmvnorm(n = n, sigma = Sigma)  lam=2*sqrt(log(p)/n) ## fixed lambda  # directed prior network prior_set=as.data.frame(matrix(data=c(5,6, 28,24), nrow=2, ncol=2, byrow = TRUE)) colnames(prior_set)=c(\"row\", \"col\") prior_set=undirected_prior(prior_set) PCGII_out=PCGII(df=X, prior=prior_set, lambda = lam) inference_out=inference(list=PCGII_out) diag(inference_out)=0 net=inference_out %>% graph_from_adjacency_matrix(mode = \"undirected\") net %>% plot(vertex.size=4, vertex.label.dist=0.5, vertex.color=\"red\", edge.arrow.size=0.5, layout=layout_in_circle(net))"},{"path":"https://haowang47.github.io/PCGII/reference/makeBlockDiag.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate block-diagonal matrix of size p by p — makeBlockDiag","title":"Generate block-diagonal matrix of size p by p — makeBlockDiag","text":"utility function generates block-diagonal matrix size p p blocks B1, B2, ..., Bk. block matrix size blocksize blocksize. -diagonal elements block matrix generated uniform (min.beta, max.beta). diagonal elements block matrix generated uniform (1, 1.25).","code":""},{"path":"https://haowang47.github.io/PCGII/reference/makeBlockDiag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate block-diagonal matrix of size p by p — makeBlockDiag","text":"","code":"makeBlockDiag(blocksize = 4, p = 20, min.beta = 0.3, max.beta = 0.9)"},{"path":"https://haowang47.github.io/PCGII/reference/makeBlockDiag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate block-diagonal matrix of size p by p — makeBlockDiag","text":"blocksize positive integer, dimension block matrix. Note, 'blocksize' factor 'p'. p positive integer, size block-diagonal matrix. min.beta positive number, lower limits uniform distribution. max.beta positive number, upper limits uniform distribution.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/makeBlockDiag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate block-diagonal matrix of size p by p — makeBlockDiag","text":"block-diagonal matrix size 'p' 'p'.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/makeBlockDiag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate block-diagonal matrix of size p by p — makeBlockDiag","text":"","code":"mat = makeBlockDiag(blocksize=4, p=20)"},{"path":"https://haowang47.github.io/PCGII/reference/make_random_precision_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","title":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","text":"utility function generates unstructured/random network skeleton simulates corresponding precision matrix. non-zero elements precision matrix generated randomly uniform distribution parameters (−upper, −lower) ∪ (lower, upper)","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_random_precision_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","text":"","code":"make_random_precision_mat(   eta = 0.01,   p = 20,   lower = 0.2,   upper = 0.5,   diag = 0.1 )"},{"path":"https://haowang47.github.io/PCGII/reference/make_random_precision_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","text":"eta number 0 1, probability drawing edge two arbitrary vertices, .e. sparsity network. p positive integer, number vertices. lower positive number, lower limits uniform distribution. upper positive number, upper limits uniform distribution. diag small positive number added diagonal elements, guarantees precision matrix positive definite.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_random_precision_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","text":"precision matrix size p p.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_random_precision_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate unstructured/random network skeleton and simulates corresponding precision matrix — make_random_precision_mat","text":"","code":"omega = make_random_precision_mat(eta=.2, p=10)"},{"path":"https://haowang47.github.io/PCGII/reference/make_sf_precision_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","title":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","text":"utility function generates scale-free network skeleton simulates corresponding precision matrix. non-zero elements precision matrix generated randomly uniform distribution parameters (−upper, −lower) ∪ (lower, upper)","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_sf_precision_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","text":"","code":"make_sf_precision_mat(   e = 1,   power = 1,   p = 20,   lower = 0.2,   upper = 0.5,   diag = 0.1 )"},{"path":"https://haowang47.github.io/PCGII/reference/make_sf_precision_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","text":"e Numeric constant, number edges add time step, see sample_pa igraph. power Numeric constant, power preferential attachment scale-free network, default 1, , see sample_pa igraph. p positive integer, number vertices. lower positive number, lower limits uniform distribution. upper positive number, upper limits uniform distribution. diag small positive number added diagonal elements, guarantees precision matrix positive definite.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_sf_precision_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","text":"precision matrix size p p.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/make_sf_precision_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate scale-free network skeleton and simulates corresponding precision matrix — make_sf_precision_mat","text":"","code":"omega = make_sf_precision_mat(e=1, p=10)"},{"path":"https://haowang47.github.io/PCGII/reference/sigs2mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function for PCGII inference results — sigs2mat","title":"Utility function for PCGII inference results — sigs2mat","text":"utility function takes PCGII inference results input generates adjacecy matrix corresponding significant partial correlations","code":""},{"path":"https://haowang47.github.io/PCGII/reference/sigs2mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function for PCGII inference results — sigs2mat","text":"","code":"sigs2mat(sigs, P)"},{"path":"https://haowang47.github.io/PCGII/reference/sigs2mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function for PCGII inference results — sigs2mat","text":"sigs dataframe locations (row, col) selected edges. P number, number nodes network.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/sigs2mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function for PCGII inference results — sigs2mat","text":"matrix size P*(P-1)/2, 0, 1.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/sigs2mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function for PCGII inference results — sigs2mat","text":"","code":"edges=cbind.data.frame(row=c(1,2,3,1,6,2,1,6,1,4), col=c(2,1,1,3,2,6,6,1,4,1)) # five edges sigs2mat(sigs = edges, P = 6) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    0    1    1    1    0    1 #> [2,]    1    0    0    0    0    1 #> [3,]    1    0    0    0    0    0 #> [4,]    1    0    0    0    0    0 #> [5,]    0    0    0    0    0    0 #> [6,]    1    1    0    0    0    0"},{"path":"https://haowang47.github.io/PCGII/reference/undirected_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","title":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","text":"utility function pre-process input prior set. function ensure input prior set corresponds undirected prior network. prior network believed directed, pre-processing prior set needed.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/undirected_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","text":"","code":"undirected_prior(prior)"},{"path":"https://haowang47.github.io/PCGII/reference/undirected_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","text":"prior k 2 data.frame prior set, row corresponds pair nodes (omics features) connected prior belief","code":""},{"path":"https://haowang47.github.io/PCGII/reference/undirected_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","text":"2-column data.frame pre-processed prior set, connection pair nodes undirected.","code":""},{"path":"https://haowang47.github.io/PCGII/reference/undirected_prior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pre-process the input prior set to ensure the input prior set corresponds to an undirected prior network — undirected_prior","text":"","code":"prior=as.data.frame(matrix(c(1,2,1,5,1,10), ncol=2, byrow=TRUE)) ## a prior set of 3 connections (1-2, 1-3, 1-10) colnames(prior)=c(\"row\", \"col\") undirected=undirected_prior(prior) ## Remark: this function is not necessary. Prior set should be considered carefully before running the network analysis. If the prior network connections are believed to be undirected while the prior set only includes one way connections for simplicity, this function will duplicate the connections and swap the direction automactically."}]
