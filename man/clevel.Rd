% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clevel.R
\name{clevel}
\alias{clevel}
\title{clevel() is the function to apply the method originally proposed in paper '> Qiu, Y., & Zhou, X. H. (2020). Estimating c-level partial correlation graphs with application to brain imaging. It is used to get the estimated partial correlation graph without information incorporation.}
\usage{
clevel(df, lambda)
}
\arguments{
\item{df}{The main expression dataset, an n by p matrix, in which each row corresponds to a sample and each column represents expression/abundance of an omics feature.}

\item{lambda}{The regularization parameter, used in the node-wise regression. If missing, default lambda will be used which is at the order of sqrt(2*log(p)/n).}
}
\value{
A list. The list contains estimated partial correlation matrix (Est), sparse partial correlation estimation matrix with threshold (EstThresh), estimated kappa (kappa), estimated test statistics matrix of partial correlations (tscore), sample size (n) and number of nodes (p).
}
\description{
clevel() is the function to apply the method originally proposed in paper '> Qiu, Y., & Zhou, X. H. (2020). Estimating c-level partial correlation graphs with application to brain imaging. It is used to get the estimated partial correlation graph without information incorporation.
}
\examples{
# Simulating data
library(igraph)
library(tidyverse)
set.seed(1234567)
n=50 # sample size
p=30 # number of nodes

g=sample_pa(p, power=1, m=1, directed = FALSE) # undirected scale-free network with the power of the preferential attachment set as 1, the number of edges to add in each time step set as 2.
plot(g, vertex.size=4, vertex.label.dist=0.5, vertex.color="red", edge.arrow.size=0.5) # visulize simulated network structure
g \%>\% plot(vertex.size=4, vertex.label.dist=0.5, vertex.color="red", edge.arrow.size=0.5, layout=layout_in_circle(g))
# compute precision matrix structure corresponding to the simulated scale-free networ
omega=as_adjacency_matrix(g) \%>\% as.matrix()
for(h1 in 1:(p-1)){
  for(h2 in (h1+1):p){
    if(omega[h1,h2]!=0){
      temp=runif(1, 0.2, 0.5)*sample(c(-1,1),size=1) # randomly assign connection strength, i.e. partial correlations
      omega[h1,h2]=temp
      omega[h2,h1]=temp
    }
  }
}
diag(omega)=rowSums(abs(omega)) # make sure precision matrix is positive definite
diag(omega)=diag(omega)+0.10

# population covariance matrix, which is used to generate data
Sigma=solve(omega)
# simulate expression data
X = rmvnorm(n = n, sigma = Sigma)

lam=2*sqrt(log(p)/n) ## fixed lambda

CLEVEL_out=clevel(df=X, lambda = lam)
## Remark: mathematical standardization will be automatically done within the function.
}
